/**
 * CIS Neural AI Dashboard - Core JavaScript Module
 * Production-grade modular dashboard system
 * 
 * @package CIS Neural AI
 * @author Ecigdis Limited
 * @version 1.0.0
 */

(function(window) {
    'use strict';
    
    /**
     * Dashboard Core Module
     */
    const Dashboard = {
        // Configuration - with safe defaults
        config: window.DASHBOARD_CONFIG || {
            API: {
                BASE_URL: '/assets/neuro/ai-agent/public/api',
                ENDPOINTS: {
                    REALTIME_METRICS: '/realtime-metrics.php',
                    BOT_MANAGEMENT: '/bot-management.php',
                    EVENT_CHAINS: '/event-chains.php',
                    TOOLS: '/tools.php',
                    LOGS: '/logs.php',
                    CONFIG: '/config.php'
                },
                REFRESH_INTERVAL: 5000,
                TIMEOUT: 30000
            },
            FEATURES: {
                REALTIME_UPDATES: true,
                EVENT_CHAINING: true,
                BOT_MANAGEMENT: true,
                ADVANCED_METRICS: true,
                LOG_STREAMING: true,
                WORKFLOW_BUILDER: true
            },
            UI: {
                THEME: 'dark',
                SIDEBAR_COLLAPSED: false,
                CHARTS_ENABLED: true,
                ANIMATIONS: true,
                NOTIFICATIONS: true
            },
            TARGETS: {
                RESPONSE_TIME_P95: 700,
                ERROR_RATE: 1,
                CACHE_HIT_RATE: 70,
                API_RETRY_COUNT: 3,
                API_RETRY_DELAY: 1000
                UPTIME: 99.9
            }
        },
        
        // State
        state: {
            initialized: false,
            refreshInterval: null,
            lastUpdate: null,
            connectionStatus: 'unknown'
        },
        
        /**
         * Initialize dashboard
         */
        init: function() {
            if (this.state.initialized) {
                console.warn('Dashboard already initialized');
                return;
            }
            
            console.log('üöÄ Initializing CIS Neural AI Dashboard...');
            
            // Initialize modules
            this.API.init();
            this.UI.init();
            this.Realtime.init();
            
            // Start auto-refresh
            if (this.config.API && this.config.API.REFRESH_INTERVAL) {
                this.startAutoRefresh();
            }
            
            this.state.initialized = true;
            console.log('‚úÖ Dashboard initialized successfully');
        },
        
        /**
         * Refresh all dashboard data
         */
        refresh: function() {
            console.log('üîÑ Refreshing dashboard data...');
            this.UI.showLoading(true);
            
            return this.API.fetchMetrics()
                .then(data => {
                    this.UI.updateMetrics(data);
                    this.state.lastUpdate = new Date();
                    this.UI.showLoading(false);
                    console.log('‚úÖ Dashboard refreshed', data);
                    return data;
                })
                .catch(error => {
                    console.error('‚ùå Dashboard refresh failed:', error);
                    this.UI.showError('Failed to refresh dashboard');
                    this.UI.showLoading(false);
                });
        },
        
        /**
         * Start auto-refresh
         */
        startAutoRefresh: function() {
            if (this.state.refreshInterval) {
                clearInterval(this.state.refreshInterval);
            }
            
            const interval = this.config.API.REFRESH_INTERVAL || 5000;
            this.state.refreshInterval = setInterval(() => {
                this.refresh();
            }, interval);
            
            console.log(`‚úÖ Auto-refresh started (${interval}ms interval)`);
        },
        
        /**
         * Stop auto-refresh
         */
        stopAutoRefresh: function() {
            if (this.state.refreshInterval) {
                clearInterval(this.state.refreshInterval);
                this.state.refreshInterval = null;
                console.log('‚è∏Ô∏è Auto-refresh stopped');
            }
        }
    };
    
    /**
     * API Module - Handles all API communication
     */
    Dashboard.API = {
        baseURL: '',
        endpoints: {},
        
        init: function() {
            const config = Dashboard.config.API || {};
            this.baseURL = config.BASE_URL || '/assets/neuro/ai-agent/public/api';
            this.endpoints = config.ENDPOINTS || {};
            console.log('üì° API module initialized', this.baseURL);
        },
        
        /**
         * Fetch with retry logic
         */
        fetchWithRetry: async function(url, options = {}, retries = 3) {
            const maxRetries = retries;
            const retryDelay = Dashboard.config.TARGETS?.API_RETRY_DELAY || 1000;
            
            for (let attempt = 1; attempt <= maxRetries; attempt++) {
                try {
                    console.log(`üì° API Request (attempt ${attempt}/${maxRetries}): ${url}`);
                    
                    const response = await fetch(url, {
                        ...options,
                        headers: {
                            'Accept': 'application/json',
                            'Content-Type': 'application/json',
                            ...options.headers
                        }
                    });
                    
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                    
                    const data = await response.json();
                    
                    if (data.success === false) {
                        throw new Error(data.error || 'API returned success=false');
                    }
                    
                    console.log(`‚úÖ API Response: ${url}`, data);
                    Dashboard.state.connectionStatus = 'connected';
                    return data;
                    
                } catch (error) {
                    console.warn(`‚ö†Ô∏è API Request failed (attempt ${attempt}/${maxRetries}):`, error.message);
                    
                    if (attempt === maxRetries) {
                        Dashboard.state.connectionStatus = 'error';
                        this.handleAPIError(url, error);
                        throw error;
                    }
                    
                    // Wait before retry
                    await new Promise(resolve => setTimeout(resolve, retryDelay * attempt));
                }
            }
        },
        
        /**
         * Handle API errors gracefully
         */
        handleAPIError: function(url, error) {
            console.error(`‚ùå API Error: ${url}`, error);
            
            // Show user-friendly error message
            const errorMessage = error.message.includes('Failed to fetch') 
                ? 'Unable to connect to API. Please check your connection.'
                : error.message.includes('HTTP 500')
                ? 'Server error. The development team has been notified.'
                : error.message.includes('HTTP 404')
                ? 'API endpoint not found. Please contact support.'
                : `API Error: ${error.message}`;
            
            Dashboard.UI.showToast(errorMessage, 'error');
            
            // Log to console for debugging
            console.error('Full error details:', {
                url,
                error: error.message,
                stack: error.stack,
                timestamp: new Date().toISOString()
            });
        },
        
        /**
         * Fetch real-time metrics with retry
         */
        fetchMetrics: function(range = 'hour') {
            const endpoint = (this.endpoints.REALTIME_METRICS || '/realtime-metrics.php') + '?range=' + range;
            const url = this.baseURL + endpoint;
            return this.fetchWithRetry(url);
        },
            }).then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                return response.json();
            });
            
            return Promise.race([fetchPromise, timeoutPromise]);
        },
        
        /**
         * Fetch real-time metrics
         */
        fetchMetrics: function(range = 'hour') {
            return this.fetch(this.endpoints.REALTIME_METRICS + '?range=' + range);
        },
        
        /**
         * Fetch bot list
         */
        fetchBots: function() {
            return this.fetch(this.endpoints.BOT_MANAGEMENT);
        },
        
        /**
         * Fetch event chains
         */
        fetchEventChains: function() {
            return this.fetch(this.endpoints.EVENT_CHAINS);
        },
        
        /**
         * Fetch tools
         */
        fetchTools: function() {
            return this.fetch(this.endpoints.TOOLS);
        }
    };
    
    /**
     * UI Module - Handles all UI updates and interactions
     */
    Dashboard.UI = {
        init: function() {
            console.log('‚úÖ UI module initialized');
            this.setupEventListeners();
            this.createToastContainer();
        },
        
        /**
         * Create toast notification container
         */
        createToastContainer: function() {
            if (document.getElementById('toast-container')) return;
            
            const container = document.createElement('div');
            container.id = 'toast-container';
            container.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                z-index: 9999;
                display: flex;
                flex-direction: column;
                gap: 10px;
            `;
            document.body.appendChild(container);
        },
        
        /**
         * Show toast notification
         */
        showToast: function(message, type = 'info', duration = 5000) {
            const container = document.getElementById('toast-container');
            if (!container) {
                console.error('Toast container not found');
                return;
            }
            
            const toast = document.createElement('div');
            toast.className = `alert alert-${this.getAlertClass(type)} alert-dismissible fade show`;
            toast.style.cssText = `
                min-width: 300px;
                max-width: 500px;
                box-shadow: 0 4px 6px rgba(0,0,0,0.1);
                animation: slideIn 0.3s ease-out;
            `;
            
            const icons = {
                success: '<i class="fas fa-check-circle me-2"></i>',
                error: '<i class="fas fa-exclamation-circle me-2"></i>',
                warning: '<i class="fas fa-exclamation-triangle me-2"></i>',
                info: '<i class="fas fa-info-circle me-2"></i>'
            };
            
            toast.innerHTML = `
                ${icons[type] || icons.info}
                ${message}
                <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
            `;
            
            container.appendChild(toast);
            
            // Auto-remove after duration
            if (duration > 0) {
                setTimeout(() => {
                    toast.style.animation = 'slideOut 0.3s ease-in';
                    setTimeout(() => toast.remove(), 300);
                }, duration);
            }
        },
        
        /**
         * Get Bootstrap alert class from type
         */
        getAlertClass: function(type) {
            const map = {
                success: 'success',
                error: 'danger',
                warning: 'warning',
                info: 'info'
            };
            return map[type] || 'info';
        },
        
        /**
         * Setup event listeners
         */
        setupEventListeners: function() {
            // Global refresh button
            document.addEventListener('click', (e) => {
                if (e.target.id === 'refreshBtn' || e.target.closest('#refreshBtn')) {
                    Dashboard.refresh();
                }
            });
        },
        
        /**
         * Update metrics display
         */
        updateMetrics: function(data) {
            if (!data || !data.metrics) {
                console.warn('No metrics data to update');
                return;
            }
            
            const metrics = data.metrics;
            
            // Update response times
            if (metrics.response_times) {
                this.updateElement('metric-response-p95', metrics.response_times.p95_ms + 'ms');
                this.updateElement('metric-response-p50', metrics.response_times.p50_ms + 'ms');
                this.updateElement('metric-total-requests', metrics.response_times.total_requests);
            }
            
            // Update cache stats
            if (metrics.cache) {
                this.updateElement('metric-cache-rate', metrics.cache.hit_rate + '%');
                this.updateElement('metric-cache-hits', metrics.cache.hits);
            }
            
            // Update error rate
            if (metrics.error_summary) {
                this.updateElement('metric-error-rate', metrics.error_summary.error_rate + '%');
                this.updateElement('metric-total-errors', metrics.error_summary.total_errors);
            }
            
            // Update token usage
            if (metrics.tokens) {
                this.updateElement('metric-tokens-total', this.formatNumber(metrics.tokens.total_tokens));
                this.updateElement('metric-tokens-cost', '$' + metrics.tokens.total_cost_usd);
            }
            
            // Update system status
            if (metrics.system) {
                this.updateElement('metric-memory', metrics.system.memory_usage_mb + ' MB');
            }
            
            // Update performance score
            if (metrics.performance_score) {
                this.updateElement('metric-score', metrics.performance_score.score);
                this.updateElement('metric-grade', metrics.performance_score.grade);
            }
            
            // Update tools table
            if (metrics.tools) {
                this.updateToolsTable(metrics.tools);
            }
            
            // Update errors table
            if (metrics.errors) {
                this.updateErrorsTable(metrics.errors);
            }
        },
        
        /**
         * Update element content safely
         */
        updateElement: function(id, value) {
            const el = document.getElementById(id);
            if (el) {
                el.textContent = value;
                el.classList.add('updated');
                setTimeout(() => el.classList.remove('updated'), 300);
            }
        },
        
        /**
         * Update tools table
         */
        updateToolsTable: function(tools) {
            const tbody = document.getElementById('tools-table-body');
            if (!tbody) return;
            
            tbody.innerHTML = tools.map(tool => `
                <tr>
                    <td>${this.escapeHTML(tool.name)}</td>
                    <td>${this.formatNumber(tool.executions)}</td>
                    <td>${tool.avg_time_ms}ms</td>
                    <td>${tool.success_rate}%</td>
                    <td><span class="badge badge-${tool.status === 'healthy' ? 'success' : tool.status === 'degraded' ? 'warning' : 'danger'}">${tool.status}</span></td>
                </tr>
            `).join('');
        },
        
        /**
         * Update errors table
         */
        updateErrorsTable: function(errors) {
            const tbody = document.getElementById('errors-table-body');
            if (!tbody) return;
            
            tbody.innerHTML = errors.map(error => `
                <tr>
                    <td>${this.escapeHTML(error.type)}</td>
                    <td title="${this.escapeHTML(error.message)}">${this.truncate(error.message, 50)}</td>
                    <td>${error.count}</td>
                    <td>${this.timeAgo(error.last_seen)}</td>
                    <td><span class="badge badge-${error.severity === 'error' ? 'danger' : 'warning'}">${error.severity}</span></td>
                </tr>
            `).join('');
        },
        
        /**
         * Show loading state
         */
        showLoading: function(show) {
            const spinner = document.getElementById('loading-spinner');
            if (spinner) {
                spinner.style.display = show ? 'block' : 'none';
            }
        },
        
        /**
         * Show error message
         */
        showError: function(message) {
            // Create toast notification (simple implementation)
            const toast = document.createElement('div');
            toast.className = 'toast-notification toast-error';
            toast.textContent = message;
            toast.style.cssText = 'position: fixed; top: 80px; right: 20px; background: var(--danger); color: white; padding: 16px 24px; border-radius: 8px; z-index: 9999;';
            document.body.appendChild(toast);
            
            setTimeout(() => {
                toast.style.opacity = '0';
                setTimeout(() => toast.remove(), 300);
            }, 3000);
        },
        
        /**
         * Utility: Format number with commas
         */
        formatNumber: function(num) {
            return num.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',');
        },
        
        /**
         * Utility: Escape HTML
         */
        escapeHTML: function(str) {
            const div = document.createElement('div');
            div.textContent = str;
            return div.innerHTML;
        },
        
        /**
         * Utility: Truncate string
         */
        truncate: function(str, length) {
            return str.length > length ? str.substring(0, length) + '...' : str;
        },
        
        /**
         * Utility: Time ago
         */
        timeAgo: function(dateString) {
            const date = new Date(dateString);
            const seconds = Math.floor((new Date() - date) / 1000);
            
            if (seconds < 60) return seconds + 's ago';
            if (seconds < 3600) return Math.floor(seconds / 60) + 'm ago';
            if (seconds < 86400) return Math.floor(seconds / 3600) + 'h ago';
            return Math.floor(seconds / 86400) + 'd ago';
        }
    };
    
    /**
     * Realtime Module - Handles real-time updates (SSE, WebSockets, etc.)
     */
    Dashboard.Realtime = {
        eventSource: null,
        
        init: function() {
            if (!Dashboard.config.FEATURES || !Dashboard.config.FEATURES.REALTIME_UPDATES) {
                console.log('‚è∏Ô∏è Real-time updates disabled');
                return;
            }
            
            console.log('‚úÖ Realtime module initialized');
            // Implement SSE or WebSocket connection here
        },
        
        /**
         * Connect to SSE stream
         */
        connect: function(endpoint) {
            if (this.eventSource) {
                this.eventSource.close();
            }
            
            this.eventSource = new EventSource(endpoint);
            
            this.eventSource.onmessage = (event) => {
                try {
                    const data = JSON.parse(event.data);
                    Dashboard.UI.updateMetrics(data);
                } catch (error) {
                    console.error('Failed to parse SSE data:', error);
                }
            };
            
            this.eventSource.onerror = (error) => {
                console.error('SSE error:', error);
                this.eventSource.close();
            };
        },
        
        /**
         * Disconnect from SSE stream
         */
        disconnect: function() {
            if (this.eventSource) {
                this.eventSource.close();
                this.eventSource = null;
            }
        }
    };
    
    // Expose Dashboard to global scope
    window.Dashboard = Dashboard;
    
    // Auto-initialize when DOM is ready
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', () => Dashboard.init());
    } else {
        Dashboard.init();
    }
    
    // Expose refresh function globally for convenience
    window.refreshDashboard = () => Dashboard.refresh();
    
})(window);
